---
title: "Vignette: WeStCOMSExploreR"
author: "Edward Lavender (el72@st-andrews.ac.uk)"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: library.bib
csl: ecology.csl
vignette: >
  %\VignetteIndexEntry{Vignette: WeStCOMSExploreR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
body{
  width: 100%;
  height: 100%;
  font-family: TimesNewRoman;
  font-size: 12pt;
  text-align: justify;
  }
  p{
  margin-bottom: 1.2em;
  }
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include = FALSE}
library(WeStCOMSExploreR)
```

# Abstract

High resolution hydrodynamic models create unprecedented opportunities to understand the spatiotemporal variation in environmental conditions in an area though time. For example, the West Scotland Coastal Ocean Modelling System (WeStCOMS) resolves environmental conditions in 3 dimensions, at resolutions of 10s to 100s of metres in the vertical and horizontal dimensions respectively, at hourly intervals. These models provide researchers working in these environments with invaluable contextual information. However, the complexity of hydrodynamic models, together with the lack of simple, open source, exploratory software -- written in a variety of widely used languages -- can make utilising their outputs a steep learning curve for researchers in other disciplines. To this end, I outline an R package designed to facilitate the exploration of outputs from WeStCOMS. This provides a gateway for the growing numbers of researchers learning and using R into the use of WeStCOMS' outputs, and those of similar hydrodynamic models, in their research. 

# Introduction

Hydrodynamic models are mathematical models which, given a set of inputs, predict hydrodynamic conditions across an area based on our knowledge of physical, oceanographic processes [@Kmpf:2009:OMB:1823110]. For researchers working in environments for which hydrodynamic models are available, these may provide a wealth of information because they move beyond the point data typically collected in a small number of locations in the study area to predictions of environmental conditions across the whole study area at high resolutions. This level of information opens the door to new research opportunities in other disciplines, such as ecology. For example, in the field of animal movement, comparing the distribution of environmental conditions experienced by tagged individuals in relation to geographic variation in environmental conditions can help identify putative movement pathways and possible habitat preferences [@braun2018].

However, understanding and using the outputs of hydrodynamic models is a steep learning curve for many researchers with backgrounds in other disciplines. In particular, one limiting factor is programming language: whilst MATLAB® is the preferred coding language for many oceanographers, a large portion of ecologists are much more familiar with R [@r2018]. Indeed, a recent study of 60,000 peer-reviewed articles in ecology found that that 58 % reported R to be their primary tool for data analysis [@doi:10.1002/ecs2.2567]. In this context, creating the capacity for researchers with experience in a variety of different programming environments, especially those that are open source, such as R, is likely to facilitate the (valuable) integration of hydrodynamic modelling and ecology. 

The West Scotland Coastal Ocean Modelling System (WeStCOMS) is a numerical, hydrostatic, hydrodynamic modelling system which can be used to resolve environmental conditions off the West Coast of Scotland [@aleynik2016]. WeStCOMS was developed at the Scottish Association for Marine Science by Dmitry Aleynik (https://www.sams.ac.uk/people/researchers/aleynik-dr-dmitry/). At the core of WeStCOMS is a finite volume community ocean model (FVCOM) module [@chen2003]. This module is forced with local atmospheric and boundary forcings, and incorporates several parameterisations (e.g. bottom roughness), tailored to the West Coast of Scotland, to estimate environmental conditions (e.g. temperature, salinity, current velocity; see Figure below). Environmental conditions are resolved across an unstructured mesh based on a system of (non-overlapping) prisms of variable size, organised into 11 vertical (Sigma) layers (layer 1 is at the surface; layer 11 is below the seabed). The unstructured mesh improves computational efficiency because resolution can be maximised in hydrodynamically complex areas and minimised elsewhere: horizontally, resolution is highest near the coast (c. 130 m resolution); vertically, resolution is highest near the surface and the seabed. Same Jones (https://www.sams.ac.uk/people/researchers/jones-dr-sam/) provides some beautiful visualisations of the 3 dimensional mesh structure (e.g. https://www.youtube.com/watch?v=3KP4Fo2FaNk). 

Some model outputs are resolved at the vertices of each prism (i.e., scalar fields, e.g. temperature), whereas other model outputs are resolved in the centroid (or 'element') of each prism (i.e., horizontal vector fields, e.g. velocity). This means that there are, in effect, two grids over which environmental conditions are resolved: one linking nodes (surrounding elements) and one linking elements (surrounding nodes). This structure has particularly important implications for researches studying benthic or demersal organisms: while the deepest model outputs for 3d scalar fields (e.g. temperature), which are resolved at prism vertices, are by the seabed, the deepest values for 3d vector fields (i.e., velocity) are resolved at the centroids of the last layer, not the vertices, which may be above the sea bottom (perhaps c. 5 - 15m, depending on the depth). Resolving bottom velocities is an ongoing research area but their extrapolation from vertical profiles derived from WeStCOMS is one possible method. Surface conditions (e.g. sea surface temperature) are reasonably well validated for WeStCOMS, but validation of bottom conditions is more challenging [@aleynik2016].

WeStCOMS provides a valuable resource to scientists conducting research off the West Coast of Scotland. However, WeStCOMS outputs are saved as MATLAB® (.mat) files and there are few codes that facilitate the exploration of these model outputs in other languages. WeStCOMSExploreR is an R package designed to facilitate the integration of WeStCOMS outputs with ecological research occurring in the same environment for researchers that are primarily familiar with R as their preferred programming language. This vignette outlines the use of some of these functions to explore the conditions off the West Coast of Scotland. 

```{r, echo = FALSE, fig.cap = "A simplified representation of the WeStCOMS modelling framework.", out.width = '100%'}
knitr::include_graphics("westcoms_framework.png")
```

# MATLAB® prerequisites 

WeStCOMS outputs are saved as MATLAB® (.mat) files. The outputs for every day are saved defined in a separate MATLAB® file. File names contain a 6 digit code which defines the date for which that file contains outputs in the format YYMMDD. For example, a file containing the information from 1st September 2016 would contain the code 160901. Each MATLAB® file contains a variety of objects, including a 'mesh' object, which defines the structure of the mesh, and an 'FVCOM1' object, which includes the environmental conditions. 

This R package attempts to minimise the MATLAB® code required by the user to explore initially the outputs of these files, preferring to offer alternatives in the form of R functions. However, prior to the use of the package to explore these outputs, it is necessary for the user to extract the following information from MATLAB® files:  

1. A dataframe that defines the nodes surrounding each element (i.e. which nodes are connected to which other nodes). This is defined in the 'mesh.trinodes' object in MATLAB®. A sample dataframe, `dat_trinodes`, is available in this package. 
2. A dataframe that contains the coordinates (longitude, latitude) for every node. This is defined in the 'mesh.nodesxy' object. A sample dataframe `dat_nodexy` is available in this package. 
3. A dataframe that contains the depth of each node below mean sea level. This is defined in the 'FVCOM1.h' object in a MATLAB® file (the depth below mean sea level is constant irrespective of date).  
4. A set of folders, one for each environmental variable of interest, each one containing a MATLAB® file which contains an array defining the values of that variable for each hour on that day, at each layer (if relevant) at at each node.  

To do this, the package includes several of R functions to streamline this process for users unfamiliar with MATLAB®. The first step is to define a dataframe, comprising a sequence of dates for which the user has MATLAB® files, that can be imported into the supplementary MATLAB® script A provided in the appendix of this document. This script attempts to loads in each MATLAB® file, to check that it is not corrupt: WeStCOMS outputs are so large, it is relatively easy for some files not to copy onto a user's local drive correctly; if so, it is better to identify these dates sooner rather than later. This sequence of dates can be defined using the `WeStCOMSExploreR::define.dates2load()` function. In this function, the user can either specify a start date and and end date, if they have access to WeStCOMS outputs for each date between these dates, or a custom vector of dates otherwise. The function returns a dataframe comprising `date` (a Date object), `year` (a 2-digit numeric object) and `date_name` (a 6 digit numeric object which reflects the WeStCOMS file name code corresponding to each date). Here, let's assume we have access to all the FVCOM files between 2016-03-01 and 2016-03-05: 
```{r}
# Use define.dates2load function to define an initial series of dates to check whether all WeStCOMS outputs are functional 
dates2load <- WeStCOMSExploreR::define.dates2load(start_date = as.Date("2016-03-01"), 
                                                  end_date = as.Date("2016-03-05"), 
                                                  corrupt_dates = NULL)

# View dates: 
dates2load 

# This dataframe should now be saved as a .csv file that can be imported into Appendix Script A. 
```

Under the hood, this function uses `WeStCOMSExploreR::date.name()` function to convert dates to date names that match WeStCOMS files. For example: 
```{r}
WeStCOMSExploreR::date.name(x = as.Date("2016-03-01"), define = "date_name")
```
It is also useful be able to reverse the process:
```{r}
WeStCOMSExploreR::date.name(x = 160301, define = "date")
```

Load this dataframe into the Appendix A script (or an improved version!) and identify any corrupt files. Having determined whether or not there are any corrupt files, the same function can be used again - this time excluding any dates for which there are corrupt files as necessary - to define a sequence of dates to be loaded into Appendix Script B, which will export arrays for each environmental variable for each day inputted. Let's say the WeStCOMS file for 2016-03-02 is corrupt, then: 
```{r}
# Define a dataframe for Appendix Script B that excludes any corrupt dates: 
dates2load <- WeStCOMSExploreR::define.dates2load(start_date = as.Date("2016-03-01"), 
                                                  end_date = as.Date("2016-03-05"), 
                                                  corrupt_dates = as.Date("2016-03-02"))

# View dates: 
dates2load 

# Save dataframe.
```

Before loading this dataframe into Appendix Script B, we need to define a sequence of folders which will contain all the environmental data for each variable of interest. This can be done manually or using the `define.dir` function:
```{r, warning = FALSE}
# Define a vector of environmental variables for which to create folders in which to store MATLAB® files;
# The functions in this package assume that, given a particular variable, these folders exist. 
vars <- c("temp", "uvelocity", "velocity", "salinity", "tidal_elevation", "uwind_speed", "vwind_speed")
# Create a folder for each environmental variable in a a specified directory (dir), here the working directory, 
# ... making sure not to overwrite any existing folders (overwrite = FALSE):
WeStCOMSpath <- system.file("WeStCOMS_files/", package = "WeStCOMSExploreR", mustWork = TRUE)
WeStCOMSExploreR::define.dir(dir = WeStCOMSpath, 
                             vars = vars
                             )
# Check that we have successfully created new folders in the specified path for each variable:
vars %in% list.files(WeStCOMSpath)
```

You are now in a position to run Appendix Script B. This script loads in the WeStCOMS file for each specified day into MATLAB® and, for each environmental variable of interest, saves another MATLAB® file which contains the information associated with that variable. The name of each file is simply the `date_name` code corresponding to that date. For 3d variables (e.g. temperature), this saves a 3d array with the structure hours x layers x node; i.e., cell 1 x 10 x 2 is the temperature for the first hour (00:00) of that day, at layer 10, at node 2. For 2d fields, a 2d array is saved (i.e. hours x nodes). These arrays are saved as .mat files which occupy less space than, perhaps, more familiar (e.g. .csv) file structures. A single copy of 'mesh.trinodes', 'mesh.nodesxy' and 'FVCOM1.h' can also be saved. This script can be adjusted as necessary (e.g. it may be suitable to only save a subset of model outputs for each environmental variable) and the user may wish to parallelise the loading/saving of files to improve computation time: this code is only provided as a simple skeleton for users unfamiliar with MATLAB® and keen to get the data into a form with which they are familiar in R. *The functions in this package assume that WeStCOMS outputs have been saved in this way (i.e., for each environmental variable, there is a folder containing files, whose names are the date names corresponding to a particular date, and each file is an array, usually with a .mat extension)*. This (unfortunate) complexity is necessary because the outputs of hydrodynamic models, like WeStCOMS, are so large. Typically, this means that data have to be partitioned into different samples (e.g. outputs for each day) which can be read in and out of R one (or at most a few) file(s) at a time. Extracting only the environmental arrays from each WeStCOMS' file reduces the storage space required to store these model outputs, and makes reading files into R much quicker. 

# Processing model outputs 

Before you proceed to build the WeStCOMS' mesh(es) and explore spatiotemporal variation in environmental conditions in the Firth of Lorn, you may wish to use the outputs you created above to define other environmental variables of interest. For example, you may wish to simplify the $u$ and $v$ components of wind velocity into wind speed; or you may wish to use the 3d temperature outputs to define a 2d representation of thermocline parameters (e.g. thermocline strength) so that you can examine how these parameters change over space. You might also want to calculate other variables, such as sun angle, which are not resolved by WeStCOMS, but quickly calculated in R, so that spatiotemporal variation in all environmental variables of interest can be expressed over the same area in the same way. This process is facilitated by the `WeStCOMSExploreR::define.new2dfield()` function. Before applying this function, add the necessary folders to your directory for storing new outputs: 
```{r, warning = FALSE}
# Define a vector of variables to derive from MATLAB outputs.
# current_speed and current_direction are also supported, but relevant sample data are not included
# ... in this package so they are not included here. thermocline_strength is also supported, 
# ... but cannot be calculated with the sample data included (see below).
new_vars <- c("wind_speed", 
              "wind_direction",
              "sun_angle")

# Define a new folder for each of these variables: 
WeStCOMSExploreR::define.dir(dir = WeStCOMSpath, 
                             vars = new_vars)

# Check
new_vars %in% list.files(WeStCOMSpath)
```

Then, the `WeStCOMSExploreR::define.new2dfield()` function can be used to create files of interest. To do this, you need to specify the dates for which you want to calculate new fields. If you want to produce files for all dates between two dates, then you need to specify a `start_date` and an end `end_date`; otherwise, you can supply a custom sequence of dates via the `dates` argument. Then, you need to define the directory from which the MATLAB® files required to calculate new fields and corresponding to each of these dates can be loaded (i.e. the directory containing the folders of model outputs for different environmental variables). (The directory new files are saved is forced to be the same directory.) save new files (by default, this is assumed to be the same. The new fields to be calculated from existing data are inputted in `vars`. Currently supported options are as follows:

1. `thermocline_strength`. For each day, for each hour and in each node, the strength of the thermocline is calculated as the difference between the temperature resolved at layer 1 and layer 10 (the bottom layer at which temperatures are resolved). This metric is used instead of other metrics (e.g. the standard deviation of a temperature profile, which has been show to be reasonable metric of thermocline strength [@fiedler2010]), because a difference is so much quicker to calculate. Note that `thermocline_strength` cannot be calculated with the sample data included in this package, which only contain temperature outputs for the $1^{st}$ and $2^{nd}$ layers (to minimise package size).
3. `wind_speed` ($ms^{-1}$). For each day, for each hour and in each node, the $u$ and $v$ components of wind velocity are used to calculate wind speed.
4. `wind_direction` ($^\circ$). As above, but for wind direction. This is the cardinal direction of mass flow (i.e. the direction in (not from) which the wind is blowing). 
5. `current speed` ($ms^{-1}$). For each date, for each hour, for each node, for each layer, current speed is calculated from the $u$ and $v$ vectors.
6. `current direction` ($^\circ$). As above, but for current direction. This is the cardinal direction of mass flow (i.e. the direction in which currents are flowing).
7. `sun angle` ($^\circ$). This is the angle of the sun relative to the horizon. It is calculated by the `WeStCOMSExploreR::sun.angle.across.mesh()` function. The calculation of sun angle uses suncalc [@thieurmel2019]. 

For each date specified, for each environmental variable, the function will save a new .RData file in the appropriate folder in the supplied directory (`dir`). (.RData files are the like the R equivalent of .mat files; they are used by WeStCOMSExploreR to maximise storage space efficiency and ensure file consistency.) For larger sequences of dates, this function can be implemented in parallel, but this is not necessary here. Note that, to calculate `sun_angle`, its necessary to include a mesh object (see below).
```{r}
WeStCOMSExploreR::define.new2dfield(vars = new_vars,
                                    nodexy = WeStCOMSExploreR::dat_nodexy,
                                    dir = WeStCOMSpath,
                                    date_name = c("160301", "160302"), 
                                    cl = NULL, 
                                    pass2varlist = list(NULL)
                                    )
# List files again:
list.files(WeStCOMSpath, recursive = TRUE)
```

# Build unstructured mesh(es)

Building the unstructured mesh is one of the first tasks a user exploring the outputs of WeStCOMS is likely to want to achieve. This can be accomplished using the `mesh.build` function, which requires two dataframe inputs: `nodexy`, a dataframe containing the coordinates (longitude, latitude) of each node; and `trinodes`, a dataframe defining the three nodes surrounding each element. In WeStCOMS, there are effectively two types of mesh: one that links elements and surrounds nodes (`mesh_type = "element"`), and one that links nodes and surrounds elements (`mesh_type = "node"`). If you want to plot environmental conditions across space (without interpolation), then the first mesh type is appropriate for plotting environmental conditions resolved at nodes, because at the heart of each cell is a node; whereas the second mesh type is appropriate for plotting environmental conditions resolved at elements, because at the heart of each cell is an element. The process of building complex meshes may take a few minutes, but a cluster object can be supplied to the `cl` argument to speed up the process. The function only needs to be run once; then the result can be saved as a Shapefile, which can be loaded into other scripts. 

This package includes a sample of information required to build the mesh in a small area around Oban. The full datasets are available from WeStCOMS outputs. Before we can build the mesh, we need to load these sample dataframes: 
```{r}
# Examine trinodes
str(WeStCOMSExploreR::dat_trinodes)
head(WeStCOMSExploreR::dat_trinodes)

# Examine nodesxyz
str(WeStCOMSExploreR::dat_nodexy)
head(WeStCOMSExploreR::dat_nodexy)
```

Using these objects, we can build the unstructured mesh: 
```{r}
# Define coordinate system (WGS84)
proj <- sp::CRS("+init=epsg:4326")

# Note that with the full mesh, you might choose to run the build.mesh algorithm in parallel. 
# This code below demonstrates how to do this; however, because we are only working with a 
# ... subset of the mesh here, this is not necessary, so I'll set cl to NULL (the default):
cl <- NULL
# If you want to define a cluster to run build.mesh algorithm in parallel (for speed): :
# cl <- parallel::makeCluster(12L)

# Use build.mesh to define a mesh based on elements (i.e. around nodes):
# This returns a SpatialPolygonsDataFrame. 
# The user is recommended to build the whole mesh and crop this to 
# ... their study domain, rather than using a subset of nodexy/trinodes to construct 
# ... the mesh (even though this can be quicker). 
dat_mesh_around_nodes <- WeStCOMSExploreR::build.mesh(nodexy = dat_nodexy, 
                                                  trinodes = dat_trinodes,
                                                  mesh_type = "element", 
                                                  proj4string = proj, 
                                                  cl = cl, 
                                                  pass2varlist = list("dat_trinodes", "dat_nodexy", "proj")
                                                  )

```

You can plot the mesh using functions in the `raster` package. First, define the boundaries of the study area of interest:
```{r}
# Define boundaries of the study area; we'll define a small area of interest around Oban: 
# A list is included in the package which includes the coordinates of this sample area:
xlim1 <- WeStCOMSExploreR::dat_area_boundaries$xlim1
xlim2 <- WeStCOMSExploreR::dat_area_boundaries$xlim2
ylim1 <- WeStCOMSExploreR::dat_area_boundaries$ylim1
ylim2 <- WeStCOMSExploreR::dat_area_boundaries$ylim2

# Define as an extent object that we'll use to crop spatial data to the study site: 
extent_study_site <- raster::extent(xlim1, xlim2, ylim1, ylim2)

# Crop mesh to be within the study area (for neatness on plot):
dat_mesh_around_nodes <- raster::crop(dat_mesh_around_nodes, extent_study_site)
```

For mapping, it is useful to have a background coastline map. Some open source data defining the coastline (technically, the administrative area defined by the UK), cropped to the limits of the study area, is included in the package as `dat_coast_around_oban`. The data come from GADM (https://www.gadm.org/index.html). Using these data, we can now proceed to plot the study area and overlay the mesh: 
```{r, fig.cap = "A sample of the WeStCOMS mesh around nodes.", fig.height = 8, fig.width = 8}
# Plot the study area
raster::plot(dat_coast_around_oban, 
             xlim = c(xlim1, xlim2), 
             ylim = c(ylim1, ylim2))

# Add the mesh as lines: 
raster::lines(dat_mesh_around_nodes)

# You can adjust this plot as you wish. 
```

In the same way, we can build and plot the mesh around elements. This should be slightly quicker. Note that, normally, you will receive a warning when you build the mesh based on nodes for every mesh element (i.e. prism): "In sp::Polygon(coords, hole) : less than 4 coordinates in polygon". This warning is flagging up that our mesh is based on triangles, which are defined by three coordinates, and can be safely ignored. For this vignette, I've hidden the warning. 
```{r, warning = FALSE, fig.cap = "A sample of the WeStCOMS mesh around elements.", fig.height = 8, fig.width = 8}
# Use build.mesh to define a mesh around elements (i.e. based on nodes): 
dat_mesh_around_elements <- WeStCOMSExploreR::build.mesh(nodexy = dat_nodexy, 
                                                     trinodes = dat_trinodes,
                                                     mesh_type = "node",
                                                     proj4string = proj, 
                                                     cl = cl,
                                                     pass2varlist = list("dat_nodexy", "dat_trinodes", "proj")
                                                     )

# Crop mesh to study area: 
dat_mesh_around_elements <- raster::crop(dat_mesh_around_elements, extent_study_site)
# Plot map and mesh:
raster::plot(dat_coast_around_oban, 
             xlim = c(xlim1, xlim2), 
             ylim = c(ylim1, ylim2))
raster::lines(dat_mesh_around_elements)
```

# Explore environmental conditions 

## Sample data

We are now in a position to explore spatiotemporal variation in environmental conditions. For each variable, environmental conditions are stored in a 2 or 3d array in a .mat file or a .RData file (if you've built these yourself using `WeStCOMSExplorer::define.new2dfield`). For example, for tidal elevation ($m$) and other 2d variables, the model outputs in the .mat files are contain a 2d array of hours (1:24) x nodes/elements. In contrast, for temperature and other 3d variables, model outputs are stored in a 3d array of hours x layers x nodes/elements. In this package, I have included two sample .mat files for each of the following variables: 

* uwind_speed (defined at layer = 1 and mesh elements)  
* vwind_speed (defined at layer = 1 and mesh elements)  
* short_wave (defined at layer = 1 and mesh nodes)  
* temperature (defined at layers = 1:10 and mesh nodes)

To reduce data volume, I have only included two hours (1, 2), two layers (1,  2, if applicable) and the subset of nodes/elements enclosed in the area defined around Oban above. For the 2d or 3d variables, this means that columns or sheets $1, 2,...n$, do not correspond to nodes/elements $1, 2,...,n$, but to nodes `dat_mesh_around_nodes$ID[1:n]` or elements `dat_mesh_around_elements$ID[1:n]`. For example, the first three columns/sheets correspond to nodes `r dat_mesh_around_nodes$ID[1:3]`, for variables resolved at nodes, or elements `r dat_mesh_around_elements$ID[1:3]`, for variables resolved at elements. Otherwise, these outputs are identical to the outputs extracted from WeStCOMS. 

To explore spatiotemporal conditions, we are going to begin by calculating summary statistics across the area at a given point in time by using `WeStCOMSExploreR::summarise2dfield()`. To apply this function, the user needs to load the WeStCOMS outputs into R, select the subset of information required and pass this reduced array to `WeStCOMSExploreR::summarise2dfield()`. We will then proceed to map the environmental conditions over space for a single point in time using the `WeStCOMSExploreR::plot2dfield()` function. `WeStCOMSExploreR::explore.WeStCOMS()` is a broader function which can produce these plots and/or calculate summary statistics over space at multiple time points. This function requires the directory of the WeStCOMS outputs which are loaded in sequence to create plots and/or calculate summary statistics. Sequentially loading, processing and replacing files is necessary given the size of WeStCOMS files. 

## Summarising environmental conditions at a single plot in time: `summarise2dfield`

### Loading raw WeStCOMS outputs into R

To summarise the the environmental conditions over space at a single point in time, `WeStCOMSExploreR::summarise2dfield()` needs to be suppplied with a 2d dimensional array. The first step is to load some WeStCOMS' outputs into R. In this example, we'll load in temperature outputs: 
```{r}
# Define directory of the folder containing temperatures:
path <- system.file("WeStCOMS_files/temp", package = "WeStCOMSExploreR", mustWork = TRUE)
# Define the path to the temperature file for 2016-03-01: 
pathname <- file.path(path, "160301.mat")
# Read in the file using the R.matlab package: 
sample <- R.matlab::readMat(pathname)
# Extract the model output (i.e. the 3d array) from the list using $data
sample <- sample$data
# Examine the structure of the array: 
str(sample)
```

### Processing outputs and calculating summary statistics

The raw, sample temperature data loaded above consists of an array with 2 rows (2 hours), 2 columns (2 layers) and 802 sheets (802 nodes). To calculate summary statistics over a 2d surface for a 3d variable, we need to select the 2d surface (i.e. the layer) over which to do so: 

```{r}
# Temperature fields are 3d, so we'll select an example layer to explore the variation in environmental
# ... conditions over space: 
sample2d <- sample[, 1, ]
```

We can now proceed to calculate summaries over the variation across nodes for each hour, or for all hours, in the array by supplying statistics of interest to the `funs` argument of `WeStCOMSExploreR::summarise2dfield`. Note that the elements of the list need to be named, with a name corresponding to the function being applied: 
```{r}
# We can now use the WeStCOMSExploreR::summarise2dfield to calculate summary statistics
# ... of the environmental conditions across this 2d field at a given time. 
# Summary statistics can be calculated for each hour separately with row_specific = TRUE:
WeStCOMSExploreR::summarise2dfield(data = sample2d, 
                                   row_specific = TRUE, 
                                   funs = list(mean = mean, min = min, max = max, sd = stats::sd, IQR = IQR))

# ... or across all the hours in a given array with row_specific = FALSE:
WeStCOMSExploreR::summarise2dfield(data = sample2d, 
                                   row_specific = FALSE, 
                                   funs = list(mean = mean, min = min, max = max, sd = stats::sd, IQR = IQR))
```

## Mapping environmental conditions at a single plot in time: `plot2dfield`

To map the environmental conditions over space at a single point in time, a little more processing is required to move from a 2d array to a dataframe, which I'll demonstrate here. For later examples, I'll cut-to-the-chase and use pre-processed datasets (which have been derived in this way) to demonstrate the use of functions. 

To use the raw data to plot a 2d field, we need to define a specific hour, a layer, and the mesh cells across which to plot environmental conditions: 
```{r}
# Define selected hour and layer 
hour4plot <- 1
layer4plot <- 1
# Subset array: 
sample4plot <- sample[hour4plot, layer4plot, 1:length(WeStCOMSExploreR::dat_nodexy$node_id)]
```

We need to convert this into a dataframe with two columns: `ID` (a unique identified of the mesh cell) and `FVCOM` (the corresponding value of the variable of interest in that cell):
```{r}
dat_temp <- data.frame(ID = WeStCOMSExploreR::dat_nodexy$node_id, fvcom = sample4plot)
head(dat_temp)
```

These two steps can be combined into a single step using `WeStCOMSExploreR::WeStCOMSarray2df()`, which takes a raw WeStCOMS array and returns a dataframe for plotting: 
```{r}
# Note that this function uses indexing to extract model outputs for selected dimensions. 
# In this case, with sample data comprising a subset of nodes, 
# ... it's necessary to flip between indexing and true IDs. 
# The user is recommend to avoid this where possible by using the full WeStCOMS arrays. 
dat_temp <- WeStCOMSExploreR::WeStCOMSarray2df(data = sample, 
                                               hour = 1, 
                                               layer = 1, 
                                               ID = 1:length(WeStCOMSExploreR::dat_nodexy$node_id))
dat_temp$ID <- WeStCOMSExploreR::dat_nodexy$node_id
head(dat_temp)
```

This information can be passed to the `WeStCOMSExploreR::plot2dfield()` function via the `data` argument. This function creates a map of the conditions resolved across the mesh. The key arguments are: `coastline`, a shapefile that will be used to delineate the coastline on the map; `mesh`, which specifies the mesh to be plotted (either a mesh around nodes or one around elements); and `vector_field`, a logical input that specifes whether or not the variable is a vector field (here, `vector_field = FALSE` since temperature is a scalar variable). There are a lot of options for graphical customisation, which you can view via `?WeStCOMSExploreR::plot2dfield()`. Here, we'll use the default options and plot temperatures resolved in the Oban area for a snapshot in time: 
```{r, fig.cap = "A map of spatial variation in temperature (degrees) around Oban (WeStCOMSExploreR::plot2dfield() scalar example 1).", fig.height = 8, fig.width = 8}
WeStCOMSExploreR::plot2dfield(coastline = WeStCOMSExploreR::dat_coast_around_oban,
                              mesh = dat_mesh_around_nodes,
                              vector_field = FALSE,
                              data = dat_temp,
                              xlim = c(xlim1, xlim2),
                              ylim = c(ylim1, ylim2),
                              zlab = expression(paste("Temperature (", degree, "C)")),
                              main = "2016-03-01"
                              )
```

We can plot other variables in the same way. For example, here is a sample of tidal outputs for the study area, processed as described above, again using default graphical parameters: 
```{r, fig.cap = "A map of spatial variation in tidal elevation (m) around Oban (WeStCOMSExploreR::plot2dfield() scalar example 2).", fig.height = 8, fig.width = 8}
WeStCOMSExploreR::plot2dfield(coastline = WeStCOMSExploreR::dat_coast_around_oban,
                              mesh = dat_mesh_around_nodes,
                              vector_field = FALSE,
                              data = dat_tidal_elevation,
                              xlim = c(xlim1, xlim2),
                              ylim = c(ylim1, ylim2),
                              zlab = "Tidal Elevation (m)",
                              main = "2016-03-01"
                              )
```


With a bit of extra processing, we can plot the surface describing the spatial variation in sun angle, using one of the files we created earlier: 
```{r, fig.cap = "A map of spatial variation in sun angle (degrees) around Oban (WeStCOMSExploreR::plot2dfield() scalar example 3).", fig.height = 10, fig.width = 10}
# Define directory of the folder containing temperatures:
path <- system.file("WeStCOMS_files/sun_angle", package = "WeStCOMSExploreR", mustWork = TRUE)
# Define the path to the temperature file for 2016-03-01; note the .RData extension:
pathname <- file.path(path, "160301.RData")
# Read in the file:
sun_angle_sample <- readRDS(pathname)
# Define a single hour for which we'll plot data: 
sun_angle_2d <- sun_angle_sample[1, ]
# Define data for plot; remember that each value corresponds to a node id
# ... specified by WeStCOMSExploreR::dat_nodexy$node_id, the dataframe used to 
# ... calculate sun angles.
dat_sun_angle <- data.frame(ID = WeStCOMSExploreR::dat_nodexy$node_id, fvcom = sun_angle_2d)
# plot sun angle: 
WeStCOMSExploreR::plot2dfield(coastline = WeStCOMSExploreR::dat_coast_around_oban,
                              mesh = dat_mesh_around_nodes,
                              vector_field = FALSE,
                              data = dat_sun_angle,
                              xlim = c(xlim1, xlim2),
                              ylim = c(ylim1, ylim2),
                              zlab = expression(paste("Sun Angle", degree, "C)")),
                              main = "2016-03-01"
                              )
```

To plot vector fields, it is necessary to specify a mesh around elements, and set `vector_field = TRUE`. The `data` need to be supplied as a list, comprising two dataframes (processed as described above), named `udata` and `vdata`: one for each vector component. 
```{r, fig.cap = "A map of spatial variation in current velocity (m/s) around Oban (WeStCOMSExploreR::plot2dfield() vector example 2).", fig.height = 8, fig.width = 8}
WeStCOMSExploreR::plot2dfield(coastline = dat_coast_around_oban,
                              mesh = dat_mesh_around_elements,
                              vector_field = TRUE,
                              data = list(udata = WeStCOMSExploreR::dat_uwind_speed,
                                          vdata = WeStCOMSExploreR::dat_vwind_speed),
                              xlim = c(xlim1, xlim2),
                              ylim = c(ylim1, ylim2),
                              # Default graphical parameters for coastline, mesh, colour scheme
                              # You can adjust the properties of the arrows for vector fields:
                              arrow_angle = 30,
                              arrow_scale = 0.0002,
                              arrow_length = 0.05,
                              arrow_lwd = 1.3,
                              arrow_lty = 1,
                              zlab = "Wind Speed (m)",
                              main = "2016-03-01"
                              )
```

## Exploring environmental conditions over space and through time: `explore.WeStCOMS`

It is often desirable to move beyond snapshots of spatial variation at particular moments in time to consider the extent to which spatial variation changes through time. To this end, the `WeStCOMSExploreR::explore.WeStCOMS()` function provides a mechanism to move over multiple variables and/or timesteps (days and hours) to calculate summary statistics and/or create plots. After this, timeseries of summary statistics can then be plotted to examine the relative scale of spatial and temporal variation, and multiple plots can be linked into animations which map how spatial variation in environmental conditions changes through time. 

To implement `WeStCOMSExploreR::explore.WeStCOMS()`, it is necessary to define `fields2d`, a dataframe which contains the environmental variables and their associated properties for which to calculate summary statistics and/or make plots. The user also needs to specify the directory from which files can be loaded, and the dates which should be loaded. If `sun_angle` has not already been calculated, this can also be achieved by defining a list of parameters to be passed to `WeStCOMSExploreR::sun.angle.across.mesh()`. To calculate summary statistics, a list of essential arguments, passed to `WeStCOMSExploreR::summarise2dfield()`, needs to supplied via the `summary_stats_param` argument . Similarly, to make plots, a list of essential parameters needs to be supplied via the `plot_param` argument, but additional customisation arguments can be supplied outside of this list that are passed to `WeStCOMSExploreR::plot2dfield()`. The function can be parallelised over environmental variables or dates by specifying inputs for the `parallelise`, `cl` and `pass2varlist` arguments. If the user opts to create plots in parallel, these need to be saved to file (they will not be displayed). 

```{r, fig.cap = "Maps of spatial variation in environmental conditions around Oban at multiple time points (WeStCOMSExploreR::explore.WeStCOMS() examples).", fig.height = 10, fig.width = 10}
# Define 2d covariates; associated layers; mesh_type
field2d <- data.frame(cov2d = c("temp",
                                 "tidal_elevation",
                                 "wind_velocity",
                                 "sun_angle"),
                       dim = c("3d", "2d", "2d", "2d"),
                       cov2dlayer =  c(1, 1, 1, 1),
                       resolved_at = c("node", "node", "element", "node"),
                       mesh_type = c("element", "element", "node", "element"),
                       extension = c(".mat", ".mat", ".RData", ".RData"),
                       vector_field = c(FALSE, FALSE, TRUE, FALSE)
                       )

# Define directory from which model outputs can be loaded:
dir2load <- system.file("WeStCOMS_files/", package = "WeStCOMSExploreR", mustWork = TRUE)

# Use WeStCOMSExploreR::explore.WeStCOMS to move over multiple variables and time points
# ... and to create plots and/or calculated summary statistics for each one. Here, 
# ... we'll save summary outputs to a list and display plots: 
summaries_ls <- 
WeStCOMSExploreR::explore.WeStCOMS(
  # Define arguments relating to data input... 
    field2d = field2d,
    mesh_around_nodes = WeStCOMSExploreR::dat_mesh_around_nodes,
    dataID_node = WeStCOMSExploreR::dat_nodexy$node_id,
    mesh_around_elements = WeStCOMSExploreR::dat_mesh_around_elements,
    dataID_element = WeStCOMSExploreR::dat_trinodes$element_id, 
    dir2load = system.file("WeStCOMS_files/", package = "WeStCOMSExploreR", mustWork = TRUE),
    date_name = c("160301", "160302"),
    # We computed sun angle previously, so this is not necessary here. 
    compute_sun_angle = FALSE,
    sun_angle_param = list(),
    # To make plots, you need to supply a list in the following format
    # Just change the objects supplied to each element: 
    makeplot = TRUE,
    plot_param = list(hours4plots = 1,
                      par_op = par(oma = c(3, 3, 3, 7)),
                      coastline = WeStCOMSExploreR::dat_coast_around_oban,
                      zlab = c(expression(paste("Temperature (", degree, ")")),
                               "Tidal Elevation (m)",
                               expression(paste("Wind Velocity (m", s^-1, ")")),
                               expression(paste("Sun Angle (", degree, ")"))
                               ),
                      zlab_line = c(3, 3, 3, 3),
                      vector_scale = c(NA, NA, 0.0002, NA),
                      # Note that if dir2save = NULL, the plots will be displayed
                      # ... and not saved to file. 
                      dir2save = NULL 
    ),
    # To compute summary statistics, again, you need to supply the following list: 
    compute_summary_stats = TRUE,
    summary_stats_param = list(hours4stats = 1:2,
                                row_specific = TRUE,
                                funs = list(mean = mean, min = min, max =  max)),
    # Options for parallelisation: 
    cl = NULL, 
    # Other graphical customisation:
    arrow_length = 0.05,
    arrow_lwd = 1.3
  )

# View summary statistics: 
summaries_ls

```

You could plot these summary statistics though time for each environmental variable and/or use external software to group any saved maps into animations. (This latter activity can be done within R, but specialised software is faster and easier to use.) For example, we could create a few timeseries plots to which help demonstrate the relative magnitude of spatial versus temporal variation using the saved summary statistics (`summaries_ls`). Even through we only have computed summary statistics across four timestamps, let's do this for illustration: 

````{r, fig.cap = "Example timeseries of the spatiotemporal variation in environmental conditions around Oban for three environmental variables, resolved at three time points.", fig.height = 4, fig.width = 8, fig.align = "center"}
# Create some timeseries plots using summary statistics
# ... that show the extent of spatial variation through time. 
# Set plotting margins and other graphical parameters: 
par(mfrow = c(1, 3))
cex1 <- 1.5
# Loop over every summary dataframe in summaries_ls... 
l <- lapply(summaries_ls, function(sdf){
  # For each summary dataframe...
  # Define timestamps using dates and hour 
  sdf$date <- WeStCOMSExploreR::date.name(sdf$date_name, define = "date")
  sdf$timestamp <- as.POSIXct(sdf$date, tz = "UTC") + (sdf$hour * 60 * 60)
  # Define y limits:
  sdf_ylims <- c(floor(min(sdf$min)), ceiling(max(sdf$max)))
  # Create blank plot:
  plot(sdf$timestamp, sdf$mean, type = "n",
       ylim = sdf_ylims,
       xlab = "",
       cex = cex1,
       cex.axis = cex1-0.2,
       cex.lab = cex1-0.2,
       las = T)
  # Add axis labels:
  mtext(side = 1, "Time (months)", cex.axis = cex1, line = 3)
  # Add a polygon which will surround a line marking the 'mean', representing the range:
  # (other polygons could be added based on other summary statistics to get a better picture
  # ... of where the 'bulk' of variation lies)
  polygon(c(sdf$timestamp, rev(sdf$timestamp)), c(sdf$min, rev(sdf$max)), col = scales::alpha("lightgrey", 0.95),
          border = F)
  # Add a line defining the mean:
  lines(sdf$timestamp, sdf$mean, lwd = 1)
  # Add points to emphasise that we only have 4 timepoints!
  points(sdf$timestamp, sdf$mean)
})
```

# Future functionality 

Future functionality includes:  

  * Creating interactive bathymetry plots;  
  * Exploring temperature profiles through space and time;  
  * Exploring spatiotemporal variation in environmental conditions in 3d;  
  * Defining bottom velocity from vertical profiles;  
  * Flexibility to define new environmental fields more easily; 


# Acknowledgements

This work was conducted during a PhD Studentship at the University of St Andrews, jointly funded by Scottish Natural Heritage and the Centre for Research into Ecological and Environmental Modelling. EL is a member of the Marine Alliance for Science and Technology Graduate School. EL is grateful to Dmitry Aleynik for thoughtful introductions and tuition in WeStCOMS. 

# Appendix

## Apendix A: A simple MATLAB® to identify corrupt files

WeStCOMSExploreR is designed to provide researchers who are unfamiliar with MATLAB® but familiar with R the capacity to explore and integrate WeStCOMS outputs in their research. Consequently, while some pre-processing in MATLAB® is still necessary to check for corrupt files and to export environmental arrays, the example codes provided to do this are kept as simple as possible. Users more familiar with MATLAB® may wish to combine these two steps, read and write files in parallel and implement a `tryCatch()`-like approach to avoid errors due to corrupt files along the way. These two scripts are only provided as a very basic guide.

```{octave, eval = FALSE}

%%% set directories... 
clear;
% set directories to necessary folders; 
% here called 'mhome', 'mat_2016' and 'mat_2016'
% the latter two directories are where WeStCOMS files are stored for 2016 and 2017 respectively. 

%%% Load dataframe that contains the dates to check
% ... e.g. created by WeStCOMSExploreR::define.dates2load()
targ = readtable([mhome 'FVCOM_filecheck.csv']);

%%% Loop over every file... 
% progress bar
p = waitbar(0, "In progress...");
% define the number of rows we'll loop over
rows = height(targ);
% for every row in the dataframe
% adjust 1:rows when the loop breaks!
for i = 1:rows,
    % display the row we are on
    disp(i);    
    % Obtain date_name and year of file to be loaded... 
    date_name = targ.date_name(i);
    yr = num2str(date_name);
    yr = str2double(yr(1:2));
    date_name_c = num2str(date_name) % date_name_c = 'date name character object'
    % Attempt to load FVCOM1 file of interest 
    % if we're dealing with 2016:
    if yr == 16, 
        % obtain the correct file from the 2016 folder (mat_2016) based on date_name
        filename = dir([mat_2016 'FVCOM1_all' date_name_c '*.mat']);
        load([mat_2016 filename(1).name]);
    % if we're dealing with 2017: 
    elseif yr == 17,
        % obtain the correct file from the 2017 folder (mat_2017)
        filename = dir([mat_2017 'FVCOM1_all' date_name_c '*.mat']);
        load([mat_2017 filename(1).name]);
    end % end if/else statements 
    % add progress bar 
    waitbar(i/rows)
    end % end the for loop 
    % close progress bar
    close(p)
```

## Apendix B: A simple MATLAB® to define environmental arrays required for WeStCOMSExploreR

```{octave, eval = FALSE}
%%% Setup
% Set directories;
% load in a dataframe which describes the files to processed 
% ... as described above; 

%%%% Loop over each date
% progress bar
p = waitbar(0, "In progress...");
% define the number of rows we'll loop over
rows = height(targ);
% for every row in the dataframe
for i = 1:rows,
    % display the row we are on
    % disp(i);
    %%%% Load FVCOM file 
    % as described in Appendix A
    %%%% Save environmental arrays as .mat files 
    % for each file, you need to first extract it into an object
    % I'll always call the object 'data' because, when we load these files
    % into R, I can use $data to identify the data each time, which
    % simplifies the R codes which take in data for multiple variables. 
    % I'll save files as matlab files, which are smaller than .csv files, 
    % and I'll load these into R. For simplicity, the file name will only
    % consist of the data_name (as a character). Again, this simplifies R
    % scripts down the line. 
    %%%% temp example
    % extract environmental array
    data = FVCOM1.t;
    % save in an appropriate folder with a date_name (character object) and a .mat extension; e.g.,
    fname = ['/Volumes/Lacie_Share/Dima/FVCOM_variable_outputs/temp/' date_name_char '.mat'];
    save(fname, 'data');
    %%%% Repeat for other variables... 
    % salinity; save in 'salinity' folder as shown above for temperature 
    data = FVCOM1.s; 
    % u_velocity; save in 'uvelocity' folder as shown above
    data = FVCOM1.u;
    % v_velocity; save in 'vvelocity' folder 
    data = FVCOM1.v; 
    % uwind_speed; save in 'uwind_speed' folder 
    data = FVCOM1.uwind_speed;
    % vwind_speed; save in 'vwind_speed' folder
    data = FVCOM1.vwind_speed; 
    % precip; save in 'precip' folder 
    data = FVCOM1.precip;
    % short_wave; save in 'short_wave' folder
    data = FVCOM1.short_wave 
    % tidal_elevation; save in 'tidal_elevation' folder
    data = FVCOM1.el;
    % update progress bar
    waitbar(i/rows);
end % end the for loop 
% close progress box
close(p);

%%%% Mesh and other properties
% Remember also to save copy of 'Mesh.trinodes', 'Mesh.nodexyz' and 'FVCOM1.h'
% ... and process these (inside or outside of MATLAB) to resembe the example
% ... data structures given in WeStCOMSExploreR. 
```

# References

